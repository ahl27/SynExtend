---
title: "Using SynExtend"
author: "Nicholas Cooley"
date: "`r Sys.Date()`"
output: 
  html_vignette
vignette: >
  %\VignetteIndexEntry{ExploreModelMatrix}
  %\VignetteEncoding{UTF-8} 
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

# Introduction

`SynExtend` is a package of tools for working with objects of class `Synteny` built from the package `DECIPHER`'s `FindSynteny()` function.

Synteny maps provide a powerful tool for quantifying and visualizing where pairs of genomes share order. Typically these maps are built from predictions of orthologous pairs, where groups of pairs that provide contiguous and sequential blocks in their respective genomes are deemed a 'syntenic block'. That designation of synteny can then used to further interogate the predicted orthologs themselves, or query topics like genomic rearrangements or ancestor genome reconstruction.

`FindSynteny` takes a different approach, finding exactly matched shared k-mers and determining where shared k-mers, or blocks of proximal shared k-mers are significant. Combining the information generated by `FindSynteny` with locations of genomic features allows us to simply mark where features are linked by syntenic k-mers. These linked features represent potential orthologous pairs, and can be easily evaluated on the basis of the syntenic k-mers that they share, or alignment.

# Package Structure

Currently `SynExtend` contains only one set of functions, but will be expanded in the future.

## Installation

1. Install the latest version of R using [CRAN](https://cran.r-project.org/).
2. Install `SynExtend` in R by running the following commands:

```{r, eval = FALSE}
if (!requireNamespace("BiocManager",
                      quietly = TRUE)) {
  install.packages("BiocManager")
}
BiocManager::install("SynExtend")
```

# Usage

Using the `FindSynteny` function in `DECIPHER` build an object of class `Synteny`. In this tutorial, a prebuilt `DECIPHER` database is used. For database construction see `?Seqs2DB` in `DECIPHER`. This example starts with a database containing three archaea genomes: Nitrosopumilus adriaticus, Nitrosopumilus piranensis, and a Candidatus Nitrosopumilus.

```{r}
library(SynExtend)

DBPATH <- system.file("extdata",
                      "VignetteSeqs.sqlite",
                      package = "SynExtend")

# Alternatively, to build this same database using DECIPHER:
# DBPATH <- tempfile()
# FNAs <- c("ftp://ftp.ncbi.nlm.nih.gov/genomes/all/GCA/006/740/685/GCA_006740685.1_ASM674068v1/GCA_006740685.1_ASM674068v1_genomic.fna.gz",
#           "ftp://ftp.ncbi.nlm.nih.gov/genomes/all/GCA/000/956/175/GCA_000956175.1_ASM95617v1/GCA_000956175.1_ASM95617v1_genomic.fna.gz",
#           "ftp://ftp.ncbi.nlm.nih.gov/genomes/all/GCA/000/875/775/GCA_000875775.1_ASM87577v1/GCA_000875775.1_ASM87577v1_genomic.fna.gz")
# for (m1 in seq_along(FNAs)) {
#  X <- readDNAStringSet(filepath = FNAs[m1])
#  X <- X[order(width(X),
#               decreasing = TRUE)]
#  
#  Seqs2DB(seqs = X,
#          type = "XStringSet",
#          dbFile = DBPATH,
#          identifier = as.character(m1),
#          verbose = TRUE)
# }

Syn <- FindSynteny(dbFile = DBPATH)
```

Synteny maps represent where genomes share order. Simply printing a synteny object to the console displays a gross level view of the data inside. Objects of class `Synteny` can also be plotted to clear visual representations of the data inside. The genomes used in this example are all from the same genus, and should be expected to be somewhat closely related.

```{r synplots01}
Syn
pairs(Syn)
```

Data present inside objects of class `Synteny` can also be accessed relatively easily. The object itself is functionally a matrix of lists, with data describing exactly matched k-mers present in the upper triangle, and data describing blocks of chained k-mers in the lower triangle. For more information see `?FindSynteny` in the package `DECIPHER`.

```{r synplots02}
print(head(Syn[[1, 2]]))
print(head(Syn[[2, 1]]))
```

The above printed objects show the data for the comparison between the first and second genome in our database.

To take advantage of these synteny maps, we can then overlay the gene calls for each genome present on top of our map.

Next, GFF annotations for the associated genomes are parsed to provide gene calls in a use-able format. GFFs are not the only possible source of appropriate gene calls, but they are the source that was used during package construction and testing. Parsed GFFs can be constructed with `gffToDataFrame`, for full functionality, or GFFs can be imported via `rtracklater::import()` for limited functionality. GeneCalls for both the `PairSummaries` and `NucleotideOverlap` functions must be named list, and those names must match `dimnames(Syn)[[1]]`.

```{r}
GeneCalls <- vector(mode = "list",
                    length = ncol(Syn))

GeneCalls[[1L]] <- gffToDataFrame(GFF = system.file("extdata",
                                                    "GCA_006740685.1_ASM674068v1_genomic.gff.gz",
                                                    package = "SynExtend"),
                                  Verbose = TRUE)
GeneCalls[[2L]] <- gffToDataFrame(GFF = system.file("extdata",
                                                    "GCA_000956175.1_ASM95617v1_genomic.gff.gz",
                                                    package = "SynExtend"),
                                  Verbose = TRUE)
GeneCalls[[3L]] <- gffToDataFrame(GFF = system.file("extdata",
                                                    "GCA_000875775.1_ASM87577v1_genomic.gff.gz",
                                                    package = "SynExtend"),
                                  Verbose = TRUE)

names(GeneCalls) <- seq(length(GeneCalls))
```

`SynExtend`'s `gffToDataFrame` function will directly import gff files into a useable format, and includes other extracted information.

```{r print gene calls}
print(head(GeneCalls[[1]]))
```

Raw GFF imports are also acceptable, but prevent alignments in amino acid space with `PairSummaries()`.

```{r show rtracklayer}
X01 <- rtracklayer::import("~/Dropbox/Packages/SynExtend/inst/extdata/GCA_000875775.1_ASM87577v1_genomic.gff.gz")
class(X01)
print(X01)
```

`SynExtend`'s primary functions provide a way to identify where pairs of genes are explicitly linked by syntenic hits, and then summarize those links. The first step is just identifying those links.

```{r generate initial links}
Links <- NucleotideOverlap(SyntenyObject = Syn,
                           GeneCalls = GeneCalls,
                           LimitIndex = FALSE,
                           Verbose = TRUE)
```

The `Links` object generated by NucleotideOverlap is a raw representation of positions on the synteny map where shared k-mers link genes between paired genomes. As such, it is analagous in shape to objects of class `Synteny`. This raw object is unlikely to be useful to most users, but has been left exposed to ensure that this data remains accessible should a user desire to have access to it.

```{r link printing}
class(Links)
print(Links)
```

This raw data can be processed to provide a straightforward summary of predicted pairs.

```{r describe links}
LinkedPairs1 <- PairSummaries(SyntenyLinks = Links,
                              GeneCalls = GeneCalls,
                              DBPATH = DBPATH,
                              PIDs = FALSE,
                              Verbose = TRUE,
                              Model = "Global",
                              Correction = "none")
```

The object `LinkedPairs1` is a data.frame where each row is populated by information about a predicted orthologous pair. By default `PairSummaries` uses a simple model to determine whether the k-mers that link a pair of genes are likely to provide an erroneous link. When set to `Model = "Global"`, is is simply a prediction of whether the involved nucleotides are likely to describe a pair of genomic features whose alignment would result in a PID that falls within a random distribution. This model is effective if somewhat permissive, but is significantly faster than performing many pairwise alignments.

```{r describe more links again}
print(head(LinkedPairs1))
```

PairSummaries includes arguments that allow for aligning all pairs that are predicted, via `PIDs = TRUE`, while `IgnoreDefaultStringSet = FALSE` indicates that alignments should be performed in nucleotide or amino acid space as is appropriate for the linked sequences. Setting `IgnoreDefaultStringSet = TRUE` will force all alignments into nucleotide space.

```{r morelinkedpairs01}
LinkedPairs2 <- PairSummaries(SyntenyLinks = Links[1:2, 1:2],
                              GeneCalls = GeneCalls[1:2],
                              DBPATH = DBPATH,
                              PIDs = TRUE,
                              IgnoreDefaultStringSet = TRUE,
                              Verbose = TRUE,
                              Model = "Global",
                              Correction = "none")
```

`LinkedPairs2` will now contain a column of PIDs, and a column indicating whether alignments were performed in nucleotide, or amino acid space.

```{r morelinkedpairs02}
print(head(LinkedPairs2))
```

A plot of predicted PIDs.

```{r}
plot(LinkedPairs2$PID,
     pch = 46,
     col = ifelse(test = LinkedPairs2$ModelSelect,
                  yes = "blue",
                  no = "red"),
     ylim = c(0, 1),
     xlab = "index",
     ylab = "PID")
```

Session Info:

```{r}
sessionInfo()
```




